<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="learning.css">
    <link rel="stylesheet" href="normalize.css">
    <title>CSS Learning</title>
    <style>
        /* Встроенные стили (второй по приоритету способ подключения) */
        p {
            text-decoration: none;
        }
    </style>
</head>
<body>
    <!--
    ===========================================
    Урок 1: Введение в CSS
    ===========================================

    Способы подключения CSS:
    1. Инлайновые стили (атрибут style) - наивысший приоритет
    2. Встроенные стили (тег <style> в head)
    3. Внешние стили (отдельный .css файл) - рекомендуемый способ

    Приоритетность стилей (от низшего к высшему):
    1. Браузерные стили (user agent stylesheet)
    2. Пользовательские стили (браузерные расширения)
    3. Авторские стили (стили разработчика)
    4. Стили во время анимации (animation)
    5. Авторские с !important
    6. Пользовательские с !important
    7. Стили во время переходов (transition)

    Наследование:
    Дочерние элементы наследуют некоторые стили родителя
    (например, color, font-family, line-height)
    -->

    <p style="color: red; text-decoration: overline;">
        Параграф с красным текстом (инлайновые стили переопределяют встроенные)
    </p>

    <p style="color: green; font-weight: 700;">
        Параграф с зеленым жирным текстом
    </p>

    <header>
        <nav>
            <ul>
                <li>Пункт 1 (наследует цвет от header)</li>
                <li>Пункт 2 (наследует цвет от header)</li>
                <li>Пункт 3 (наследует цвет от header)</li>
            </ul>
        </nav>
    </header>

    <!--
    ===========================================
    Урок 2: CSS-селекторы
    ===========================================

    Основные типы селекторов:
    1. По тегу: `tag { }`
    2. По классу: `.class { }` (рекомендуемый способ)
    3. По id: `#id { }` (не рекомендуется для стилей)
    4. По атрибуту: `[attr="value"] { }`

    Комбинаторы:
    1. Потомки: `parent child { }`
    2. Дочерние: `parent > child { }`
    3. Соседние: `element + sibling { }`
    4. Общие соседи: `element ~ siblings { }`
    -->

    <section>
        <h2 id="test">Тестовая секция</h2>
        <p class="user-warning">Читать только, если прошел все части Mario Kart</p>
        <form>
            <input type="checkbox" name="user-test" id="warning-test">
            <label for="warning-test" id="id-selector">Поставь галочку, если прочитал текст выше</label>
        </form>
    </section>

    <section>
        <p>
            Текст внутри секции
            <span>и внутри span (стиль через селектор потомков)</span>
        </p>
    </section>

    <h1>Заголовок 1 уровня</h1>
    <h2>Заголовок 2 уровня</h2>
    <h3>Заголовок 3 уровня</h3>

    <form>
        <button class="button">Открыть меню</button>
        <button class="button is-active">Закрыть меню</button>
    </form>

    <form>
        <label for="user-message">Введите сообщение</label>
        <input class="input is-invalid" id="user-message">
        <div class="error-message">
            Введенные вами данные некорректны! (отображается через соседний селектор +)
        </div>
    </form>

    <p class="parag">Параграф</p>
    <p class="parag">Параграф</p>
    <h2 class="using-after">Элемент, после которого меняются стили (через ~)</h2>
    <p class="parag">Параграф (измененный стиль)</p>
    <p class="parag">Параграф (измененный стиль)</p>

    <!--
    ===========================================
    Урок 3:  Блочная модель в CSS
    ===========================================

    Свойство:
    -display
    Значения:

    1.Block
    1.1 Занимает всю ширину родителя.
    1.2 Можно задавать width, height, margin, padding.
    1.3 Используется для div по умолчанию.

    2. Inline
    2.1 Занимает ровно столько места, сколько нужно контенту внутри.
    2.2 Нельзя задавать width, height, margin-top/bottom.

    3. Inline-block
    3.1 Ведет себя как inline
    3.2 Но можно задавать width, height, margin, padding.

    4. None
    4.1 Позволяет полностью скрыть элемент со страницы
    4.2 Элемент все еще доступен для разметки

    Свойство: padding
    - padding: 15px -> отступы внутри по 15 пикселей с каждой стороны
    - padding: 15px 40px -> отступы внутри: 15px сверху и снизу, 40px справа и слева

    Свойство: border
    - border: 5px solid red -> указывать: ширина + тип линии + цвет(черный по умолчанию) в любом порядке

    Свойство: box-sizing
    - content-box -> width и height задаются только для контента, border и padding добавляются снаружи
    - border-box -> width и height включают в себя border и padding, размер элемента остается фиксированным.


    Важно:
    Итоговые width и height считаются с учетом padding, border и других свойств. Margin не прибавляется!
    -->

    <div class="block-obj">Я - блок(блочный элемент)</div>

    <span class="inline-obj">А я - строчный элемент</span>

    <span class="inline-block-obj">А я - строчно-блочный элемент</span>

    <div class="none-obj">А я - неотображаемый элемент</div>

    <div class="test-block">Padding: 15px 40px</div>

    <div class="common-box">Я просто блок</div>

    <div class="common-box normal-size">А я блок с фиксированным размерами</div>

    <div class="rule-breaking-block">А я нарушаю правила</div>

    <!--
    ===========================================
    Урок 4: Внутренние и внешние отступы в CSS
    ===========================================

    Свойство: padding
    - Одно значение -> применяется на все стороны относительно объекта
    - Два значения -> верх и низ + право и лево
    - Три значения -> верх + право и лево + низ
    - Четрые значения -> верх + право + низ + лево

    - Уpadding также существует несколько версий для добавления отступов в отдельной стороне:
    -top,-right,-botttom,-left -> для каждой стороны
    -block, -inline -> по вертикали и горизонтали соответственно


    Свойство: margin
    Значения регулируются аналогично padding.

    Обратить внимание:
    -Возможно установить значение margin: auto, в таком случае браузер сам решит, сколько нужно сделать отступы.
    - Значение magin может быть отрицательно

    Важно:
    - При столкновении двух margin у разных элементов браузер выберет наибольший и применит его, например при столкновении двух элементов с отступами 50 и 100 друг от друга, расстояние между ними будет 100.

    -->

    <!--
    ===========================================
    Урок 5: Обнуляющие стили CSS
    ===========================================

    Normalize CSS/ Reset CSS использовать для стандартизации стилей под все браузеры.

    -->

    <!--
    ===========================================
    Урок 6: Шрифты в CSS
    ===========================================

    Все форматы шрифтов:
    - eot,svg,ttf,woff - старые форматы шрифтов
     - woff2 - новый формат шрифтов

     Применение:
     - нужно использовать свойство font-family в стилях(наследуется)

     Всего 3 способа использования:
    1. Через @font-face (экономия трафика) - лучший вариант
    2. Через @import с указанием url
    3. Через link

    transfonter.org - сервис для конвертации шрифтов в нужный формат

    Свойство line-height:
    - Задает межстрочный интервал

    -->

    <section class="example">
        <header class="list-head">Типы шрифтов</header>
        <div class="font-list">
            <p style="font-weight: 100;">Thin 100</p>
            <p style="font-weight: 200;">Extralight 200</p>
            <p style="font-weight: 300;">Light 300</p>
            <p style="font-weight: 400;">Regular 400</p>
            <p style="font-weight: 500;">Medium 500</p>
            <p style="font-weight: 600;">SemiBold 600</p>
            <p style="font-weight: 700;">Bold 700</p>
            <p style="font-weight: 800;">ExtraBold 800</p>
            <p style="font-weight: 900;">Black 900</p>
        </div>
    </section>

    <section class="example">
        <div class="font-list">
            <p>Я стандартный шрифт</p>
            <p class="font-black">Я Roboto шрифт в black начертании</p>
        </div>
    </section>

    <section class="example">
        <header class="list-head">Преобразовать шрифт в нужный формат</header>
        <a href="https://transfonter.org/" class="transfer-link" target="_blank">Нажми сюда!</a>
    </section>

    <!--
    ===========================================
    Урок 7: Цвета в CSS #1`
    ===========================================

    Существует несколько форматов, при помощи которых задают цвета. Рассмотрим основные:
    - color: white -> цвет задается через латинское наименование/некий цифровой индекс
    - color: rgb(255 255 255) -> цвет задается через rgb формат при помощи чисел
    - color: #fff -> цвет задается через по тому же принципу, что и rgb, но только через цифро-буквенные комбинации

    Важно:
    - Существует color: transparent; . Используют, чтобы сделать элемент прозрачным
    - Если указать для какого-либо объекта color, то при редактировании элемента дальше можно не дублировать этот же цвет, а использовать currentColor.


    -->

    <section class="example new-style">
        <header class="list-head">Цвета в CSS </header>
        <div class="color-box">
            <p style="color: red;">Я - красный текст </p>
        </div>
        <section class="example common">
            <div class="color-box" style="line-height: 0.8;">
                <p style="color: rgb(255 255 255);">Белый (255;255;255)</p>
                <p style="color: rgb(0 0 255);">Синий (0;0;255)</p>
                <p style="color: rgb(255 0 0);">Красный (255;0;0)</p>
            </div>
        </section>
    </section>

    <!--
    ===========================================
    Урок 8: Цвета в CSS #2
    ===========================================

    Свойтсво:
    - background:
    Позволяет использовать сразу несколько свойств внутри себя (-color,-image,-repeat,-position,-size,-attachment,-clip)

    Градиенты:
    - Задаются фоном к элементу при помощи background-image: linear-gradient(indianred,cornflowerblue);
    - Всего есть 3 типа градиентов в css: linear,radial,conic, а также свойство repeating для их повторения и deg/turn для определения градуса градиента(прописывается в самом начале перед перечислением цветов)

    Важно:
    - Можно прописать порог вхождение и выхода каждого цвета в градиенте, дописав значение(я) в процентах после каждого цвета. Если процент входа и выхода двух соседних элементов соовпадет, то плавный переход превратится в статичный.

    -->

    <section class="example">
        <header class="list-head">Градиенты</header>
        <div class="grad-boxes">
            <div class="box-1"></div>
            <div class="box-2"></div>
            <div class="box-3"></div>
        </div>
    </section>

    <section class="example new-style">
        <header class="list-head">Управление точками перехода</header>
        <div class="box-example"></div>
    </section>

    <section class="example">
        <header class="list-head">Ссылка на генератор градиентов</header>
        <a href="https://cssgradient.io" target="_blank" style="text-decoration: none; background-image: linear-gradient(90grad, red, orange,yellow); color: black;">Кликни сюда!</a>
    </section>


    <!--
    ===========================================
    Урок 9: Рамки, обводки, тени, фильтры в CSS
    ===========================================

    Свойство:
    -outline:
    Задает обводку нужному элементу, при этом не добавляет элементу в размерах, в отличие от border
    Работает по тому же принципу, что и border.

    -border-radius:
    Дает возможность сделать края элемента круглыми.

    -box-shadow:
    Задает тени для выбранных объектов. Изменяюются только четыре значения: первое - по горизонатли, второе - по вертикали, третье - радиус раззмытия, четвертое - радиус распространения(размеры). А также после данных значений можно указать цвет в любом его формате. Дополнительно можно использовать свойство inset после этого, оно меняет расположение теней с внешнего на внутреннее

    -filter:
    Добавляет возможность менять фильтры для картинок внутри сайта.
    Можно указать drop-shadow(анвлог box-shadow), что позволит добавить тени для объекта формата .png

    -->
    <section class="example">
        <header class="list-head">Границы</header>
        <div class="box"></div>
        <div class="box broken-outline"></div>
    </section>

    <section class="example">
        <header class="list-head">Ссылка на генератор закруглений</header>
        <a href="https://9elements.github.io/fancy-border-radius/" target="_blank" style="text-decoration: none; background-image: linear-gradient(67grad, blue,green,lightgreen); color: #fff">Кликни сюда!</a>
    </section>

        <section class="example">
        <header class="list-head">Тени</header>
        <div class="shadow box"></div>
    </section>

    <!--
    ===========================================
    Урок 10: Позиционирование в CSS
    ===========================================

    Свойство:
    -position:
    Позволяет определить позицию нужного элемента относительно его окружения на сайте.
    --static:
    Значение по умолчанию, элемент будет расположен в порядке очереди
    Не могут быть применены top,right,left,botttom,inset,z-index

    --relative:
    Тот же static, только теперь на объект будут работать смещения типа left,right и т.п

    --absolute:
    Выбивает элемент из очереди, соседние объекты типа relative и др, без указания смещения у absolute-элемента, будут принимать этот элемент поверх себя, накладываться друг на друга.
    Используют вместе со смещениями типа top,right и др.
    Смещения применяются относительно ближайшего не static элемента в <body>. Если такого элемента нет, то смещения работают относительно самого <body>
    Даже если элемент типа display: block; , он все равно будет занимать ровно столько места, сколько ему нужно.
    Часто комбинируют с relative-объектами

    --fixed:
    Использует в случае, когда нужно закрепить элемент относительно границ страницы, чтобы пользователь при прокрутке видел элемент постоянно.
    Это значение всегда работает от границ страницы, в отличие от absolute

    --sticky:
    Позволяет зафиксировать элемент, чтобы при видимости его родительских элементов при прокрутке также был виден и sticky-элемент

    -inset(top,right,left.bottom)
    Вышеперечисленный в скобках список параметров позволяет переместить любой (*не static) позиционированный элемент в нужном направлении, а inset объединяет их в одно свойство и принимает до 4 аргументов по давно изученной методика, например как у padding

    -z-index:
    Позволяет менять порядок наложения элементов одного позиционирования по мере увеличение индекса вверх по числовой системе
    Важно:
    Индекс родительского элемента всегда будет <= индексу дочернего элемента

    -->

    <section class="example new-style">
        <header class="list-head">Позиционирование</header>
        <div class="positions-box">
            <div class="box one">
                position: static;
            </div>
            <div class="box two">
                position: relative;
                top: 50px;
                left: 100px;
            </div>
            <div class="box three">
                position: absolute;
                z-index: 100;
                top: 100px;
                left: 250px;
            </div>
            <div class="box four">
                position: fixed;
                top: 580px;
                left: 330px;
            </div>
            <div class="box five">
                position: sticky;
                top: 0;
                left: 20px;
            </div>
        </div>
    </section>


    <section class="example new-style"
    style="
    border-style: none;">
        <div class="some-box"
        style="
            position: fixed;
            width: 400px;
            height: 200px;
            bottom: 0;
            right: 0;
            background-color: #000;"><p style="color: #fff;">Тут должно было быть видео,а вообще это фиксированный элемент через position: fixed;</p></div>
    </section>

    <!--
    ===========================================
    Урок 11: Единицы измерения в CSS
    ===========================================

    Единицы измерения в CSS делят на относительные и абсолютные. Так, например, vw высчитывается исходя из области экрана, на котором в данныый момент просматривается контент с vw, также em считается исходя из размера шрифта.Mm и px в свою очередь величины абсолюьные и не зависят от каких-либо факторов из их окружения.

    -->

    <section class="example new-style">
        <header class="list-head">Единицы измерения</header>
        <div class="elem-box">
            <div class="elem-1">
                Ширина 50vw
            </div>
            <div class="elem-2">
                Ширина 15em при размере шрифта 30px
            </div>
            <div class="elem-3">
                Ширина 200px
            </div>
            <div class="elem-4">
                Ширина 30mm
            </div>
        </div>
    </section>

    <!--
    ===========================================
    Урок 12:  CSS FlexBox Layout
    ===========================================

    Flex-конетейнром считается любой элемент, к которому применено свойство display: flex. Это свойство наследуется

    Изначально простой flex элемент будет вести себя так, словно он display:block. А если применить display:inline-flex, то элемент будет вести себя так, будто он строка

    Свойство:
    -flex-direction:
    Позволяет менять напраление заполнения(изначально - слева направо 'row').

    -flex-wrap:
    Элементы в flex-контейнере по умолчанию пытаются поместиться в одну строку, даже если при их размерах это невозможно, из-за чего заданные пользователем размеры игнорируются. Чтобы избежать этого, нужно выставить значение flex-wrap на wrap
    Существует также flex-wrap: wrap-reverse, что позволяет перевернуть список

    -flex-flow:
    Объединяет в себе flex-direction и flex-wrap, указывать через пробел

    -flex-grow:
    Позволяет растягивать элемент(ы) по всей ширине относительно соседних элементов, если для этого действия есть свободное пространство.
    Работает даже при имеющихся значениях высоты и ширины.

    -flex-basis:
    Переопределяет размеры элемента по основоному направлению(row - горизонт, column - вертикаль)
    Приоритетнее width,height и т.п

    -flex:
    Объединяет через пробел grow,shrink и basis

    -order:
    Позволяет определять порядок расстановки элемента в flex-контейнере

    -justify-content:
    Определяет положение элементов внутри flex-контейнера по основной оси

    --flex-start:
    Элементы прижимаются к старту контейнера

    --flex-end:
    Элементы прижимаются к концу контейнера

    --center:
    Элементы распологаются ровно в центре контейнера

    --space-between:
    Первый и последний элементы расположены строго по краям контейнера, остальные же выстраиваются с одинаковыми отступами на всем свободном пространстве

    -align items:
    Определяет положение элементов внутри flex-контейнера по побочной оси

    --stretch:
    Значение по умолчанию, элементы заполняют все свободное пространство flex-контейнера

    --flex-start:
    Элементы располагаются в самом начале их побочной оси  внутри flex-контейнера

    --flex-end:
    Элементы располагаются в конце их побочной оси  внутри flex-контейнера

    --center:
    Элементы располагаются в самом центре их побочной оси внутри flex-контейнера

    --baseline:
    Элементы будут выравнены по базовой линии текста

    -align-content:
    Определяет положение рядов в flex-контейнере, работает аналогично justify-content

    -gap/row-gap/column-gap:
    Позволяет задать отступы между элементами в flex-котейнере.

    -->

    <section class="example-flex">
        <header class="list-head">display: flex</header>
        <div class="flex-container">
            <div class="flex-element">
                Элемент 1
            </div>
            <div class="flex-element">
                Элемент 2
            </div>
        </div>
    </section>

    <section class="example-flex">
        <header class="list-head">display: flex + -flex-direction: row-reverse</header>
        <div class="flex-container flex-row-reverse">
            <div class="flex-element">
                Элемент 1
            </div>
            <div class="flex-element">
                Элемент 2
            </div>
        </div>
    </section>

    <section class="example-flex">
        <header class="list-head">display: flex + flex-direction: column</header>
        <div class="flex-container flex-column">
            <div class="flex-element">
                Элемент 1
            </div>
            <div class="flex-element">
                Элемент 2
            </div>
        </div>
    </section>

    <section class="example-flex">
        <header class="list-head">display: flex + flex-direction: column-reverse</header>
        <div class="flex-container flex-column-reverse">
            <div class="flex-element">
                Элемент 1
            </div>
            <div class="flex-element">
                Элемент 2
            </div>
        </div>
    </section>



    <div>
        display: flex
    </div>
    <div class="flex-container">
        <div class="flex-element new-elem">1</div>
        <div class="flex-element new-elem">2</div>
        <div class="flex-element new-elem">3</div>
        <div class="flex-element new-elem">4</div>
        <div class="flex-element new-elem">5</div>
        <div class="flex-element new-elem">6</div>
        <div class="flex-element new-elem">7</div>
        <div class="flex-element new-elem">8</div>
        <div class="flex-element new-elem">9</div>
        <div class="flex-element new-elem">10</div>
    </div>


    <div>
        display: flex + flex-wrap: wrap
    </div>
    <div class="flex-container flex-wrap">
        <div class="flex-element new-elem">1</div>
        <div class="flex-element new-elem">2</div>
        <div class="flex-element new-elem">3</div>
        <div class="flex-element new-elem">4</div>
        <div class="flex-element new-elem">5</div>
        <div class="flex-element new-elem">6</div>
        <div class="flex-element new-elem">7</div>
        <div class="flex-element new-elem">8</div>
        <div class="flex-element new-elem">9</div>
        <div class="flex-element new-elem">10</div>
    </div>


    <div>Flex-grow по умолчанию</div>
    <div class="flex-container stylish">
        <div class="flex-element">1</div>
        <div class="flex-element">2</div>
        <div class="flex-element">3</div>
        <div class="flex-element">4</div>
    </div>

    <div>Flex-grow: 1; для всех элементов</div>
    <div class="flex-container stylish">
        <div class="flex-element elems-grow">1</div>
        <div class="flex-element elems-grow">2</div>
        <div class="flex-element elems-grow">3</div>
        <div class="flex-element elems-grow">4</div>
    </div>

    <div>Flex-grow: 1; для одного элемента</div>
    <div class="flex-container stylish">
        <div class="flex-element elem-grow">1</div>
        <div class="flex-element">2</div>
        <div class="flex-element">3</div>
        <div class="flex-element">4</div>
    </div>

    <div>Flex-shrink по умолчанию</div>
    <div class="flex-container stylish test">
        <div class="flex-element">1</div>
        <div class="flex-element">2</div>
        <div class="flex-element">3</div>
        <div class="flex-element">4</div>
    </div>

    <div>Flex-shrink: 0; для всех элементов (не игнорируют свои реальные азмеры)</div>
    <div class="flex-container stylish test">
        <div class="flex-element elems-shrink">1</div>
        <div class="flex-element elems-shrink">2</div>
        <div class="flex-element elems-shrink">3</div>
        <div class="flex-element elems-shrink">4</div>
    </div>

    <div>Flex-shrink: 2; для одного элемента + бонусный порядок элементов</div>
    <div class="flex-container stylish test">
        <div class="flex-element elem-shrink order-last">1</div>
        <div class="flex-element order-2">2</div>
        <div class="flex-element order-1">3</div>
        <div class="flex-element order-3">4</div>
    </div>

    <div>align-items: baseline (Выравнивание по тексту)</div>
    <hr>
    <div class="new-flex-container">
        <div class="new-flex-element"><h1>Lorem ipsum dolor sit amet</h1>
        </div>
        <div class="new-flex-element"><h2>Lorem ipsum dolor sit amet</h2>
        </div>
        <div class="new-flex-element"><h3>Lorem ipsum dolor sit amet</h3>
        </div>
        <div class="new-flex-element"><h4>Lorem ipsum dolor sit amet</h4>
        </div>
    </div>

    <!--
    ===========================================
    Урок 13: Псевдоэлементы в CSS
    ===========================================

    Псевдоэлементы позволяют добавлять к элементам доп контент, который нельзя добавить через html

    -->

     <section class="example">

        <header class="list-head"> Псевдоэлементы</header>

        <p class="with-before">
            Элемент с псевдоэлементом::before
        </p>

        <p class="with-after">
            Элемент с псевдоэлементом::after
        </p>

        <input type="text" class="with-red-placeholder" placeholder="Красный placeholder">

        <input type="file" class="with-file-selector-button">

        <p class="with-first-letter">
            Элемент с псевдоэлементом::first-letter
        </p>

        <p class="with-first-line">
            Элемент <br>
            с псевдоэлементом <br>
            ::first-line
        </p>

        <p class="with-selection">
            Элемент с псевдоэлементом::selection
        </p>

        <ul>
            <li>Элемент списка</li>
            <li class="with-marker">Элемент списка с псевдоэлементом::marker</li>
            <li>Элемент списка</li>
        </ul>

     </section>


     <!--
     ===========================================
     Урок 14: Псевдоклассы в CSS
     ===========================================

    Псевдокласс :child :
    -Позволяет обратиться к какому-либо дочернему элементу по его номеру или признаку (например по четности - :nth-child(odd/even))
    Дополнительно:
    nth-last-child обращается к элментами по порядку с самого конца
    nth-child(?n) позволяет выбрать определенный порядок обращения к элементу (например к каждому 3 -> 3n)
    nth-child(-n + ?) позволяет выбрать определенное кол-во элементов с самого начала, на которые можно будет воздействовать этим псевдоклассом
    only-child обращается к элементу, если он является единственным дочерним

    Псевдокласс :not :
    Позволяет инвертировать действие другого псе

    Псевдокласс disabled:
    Деактивирует возможности input,button и т.п

    Псевдокласс checked:
    Работает только с input:radio/checkbox, позволяет изменять бокс с галочкой в определенном состоянии

     -->
     <section class="example">
        <header class="list-head">Ссылка на кастомный nth-child</header>
        <a href="https://nth-child.belter.io/" target="_blank" style="text-decoration: none;">Ссылка!</a>
    </section>

    <section class="example">
        <header class="list-head">Псевдоклассы состояни</header>

        <button class="hover-eff">
            Hover состояние
        </button>

        <button class="focus-eff">
            Focus состояние
        </button>

        <button class="focus-visible-eff">
            Focus-visible состояние
        </button>

        <button class="active-eff">
            Active состояние
        </button>

    </section>

    <!--
    ===========================================
    Урок 15: CSS Grid Layout
    ===========================================
    -->

</body>
</html>
